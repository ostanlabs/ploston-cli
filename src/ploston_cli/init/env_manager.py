"""Environment File Manager - Generate and manage ~/.ploston/.env.

This module handles the generation and management of the .env file
that stores secrets for the local runner.
"""

from __future__ import annotations

import secrets
from pathlib import Path

# Default paths
PLOSTON_DIR = Path.home() / ".ploston"
ENV_FILE = PLOSTON_DIR / ".env"


def generate_runner_token() -> str:
    """Generate a secure token for runner authentication.

    Returns:
        Token string in format "plr_<random>"
    """
    return f"plr_{secrets.token_urlsafe(32)}"


def write_env_file(
    runner_token: str,
    env_vars: dict[str, str | None] | None = None,
    env_file_path: Path | None = None,
) -> Path:
    """Write .env file with runner token and detected secrets.

    Args:
        runner_token: Auto-generated runner authentication token
        env_vars: Dict of env var names to values (None = placeholder)
        env_file_path: Optional custom path (defaults to ~/.ploston/.env)

    Returns:
        Path to the written .env file
    """
    env_file = env_file_path or ENV_FILE
    env_file.parent.mkdir(parents=True, exist_ok=True)

    lines = [
        "# Generated by: ploston init --import",
        "# Secrets for Ploston local runner",
        "",
        "# Runner authentication (auto-generated)",
        f"PLOSTON_RUNNER_TOKEN={runner_token}",
    ]

    # Add detected secrets
    if env_vars:
        secret_vars = {k: v for k, v in env_vars.items() if k != "PLOSTON_RUNNER_TOKEN"}
        if secret_vars:
            lines.append("")
            lines.append("# Imported MCP server secrets")
            for var_name, value in sorted(secret_vars.items()):
                if value:
                    lines.append(f"{var_name}={value}")
                else:
                    lines.append(f"{var_name}=  # TODO: Set this value")

    env_file.write_text("\n".join(lines) + "\n")
    return env_file


def load_env_file(env_file_path: Path | None = None) -> dict[str, str]:
    """Load environment variables from .env file.

    Args:
        env_file_path: Optional custom path (defaults to ~/.ploston/.env)

    Returns:
        Dict of environment variable names to values
    """
    env_file = env_file_path or ENV_FILE
    if not env_file.exists():
        return {}

    env_vars: dict[str, str] = {}
    for line in env_file.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" in line:
            key, _, value = line.partition("=")
            key = key.strip()
            value = value.strip()
            # Remove inline comments
            if "#" in value and not value.startswith('"') and not value.startswith("'"):
                value = value.split("#")[0].strip()
            env_vars[key] = value
    return env_vars


def update_env_file(
    updates: dict[str, str],
    env_file_path: Path | None = None,
) -> Path:
    """Update existing .env file with new values.

    Args:
        updates: Dict of env var names to new values
        env_file_path: Optional custom path (defaults to ~/.ploston/.env)

    Returns:
        Path to the updated .env file
    """
    env_file = env_file_path or ENV_FILE

    # Load existing
    existing = load_env_file(env_file)

    # Merge updates
    existing.update(updates)

    # Get runner token (required)
    runner_token = existing.pop("PLOSTON_RUNNER_TOKEN", generate_runner_token())

    # Write back
    return write_env_file(runner_token, existing, env_file)


class EnvFileManager:
    """Manager for .env file operations.

    Provides a class-based interface for env file management.
    """

    def __init__(self, env_file_path: Path | None = None):
        """Initialize manager.

        Args:
            env_file_path: Optional custom path (defaults to ~/.ploston/.env)
        """
        self.env_file = env_file_path or ENV_FILE

    def generate_token(self) -> str:
        """Generate a new runner token."""
        return generate_runner_token()

    def write(
        self,
        runner_token: str,
        env_vars: dict[str, str | None] | None = None,
    ) -> Path:
        """Write .env file."""
        return write_env_file(runner_token, env_vars, self.env_file)

    def load(self) -> dict[str, str]:
        """Load .env file."""
        return load_env_file(self.env_file)

    def update(self, updates: dict[str, str]) -> Path:
        """Update .env file."""
        return update_env_file(updates, self.env_file)

    @property
    def exists(self) -> bool:
        """Check if .env file exists."""
        return self.env_file.exists()
