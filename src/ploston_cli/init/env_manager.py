"""Environment File Manager - Generate and manage ~/.ploston/.env.

This module handles the generation and management of the .env file
that stores secrets for the local runner.
"""

from __future__ import annotations

import secrets
from pathlib import Path

# Default paths
PLOSTON_DIR = Path.home() / ".ploston"
ENV_FILE = PLOSTON_DIR / ".env"


def generate_runner_token() -> str:
    """Generate a secure token for runner authentication.

    Returns:
        Token string in format "plr_<random>"
    """
    return f"plr_{secrets.token_urlsafe(32)}"


def write_env_file(
    runner_token: str,
    env_vars: dict[str, str | None] | None = None,
    env_file_path: Path | None = None,
) -> Path:
    """Write .env file with runner token and detected secrets.

    Args:
        runner_token: Auto-generated runner authentication token
        env_vars: Dict of env var names to values (None = placeholder)
        env_file_path: Optional custom path (defaults to ~/.ploston/.env)

    Returns:
        Path to the written .env file
    """
    env_file = env_file_path or ENV_FILE
    env_file.parent.mkdir(parents=True, exist_ok=True)

    lines = [
        "# Generated by: ploston init --import",
        "# Secrets for Ploston local runner",
        "",
        "# Runner authentication (auto-generated)",
        f"PLOSTON_RUNNER_TOKEN={runner_token}",
    ]

    # Add detected secrets
    if env_vars:
        secret_vars = {k: v for k, v in env_vars.items() if k != "PLOSTON_RUNNER_TOKEN"}
        if secret_vars:
            lines.append("")
            lines.append("# Imported MCP server secrets")
            for var_name, value in sorted(secret_vars.items()):
                if value:
                    lines.append(f"{var_name}={value}")
                else:
                    lines.append(f"{var_name}=  # TODO: Set this value")

    env_file.write_text("\n".join(lines) + "\n")
    return env_file


def load_env_file(env_file_path: Path | None = None) -> dict[str, str]:
    """Load environment variables from .env file.

    Args:
        env_file_path: Optional custom path (defaults to ~/.ploston/.env)

    Returns:
        Dict of environment variable names to values
    """
    env_file = env_file_path or ENV_FILE
    if not env_file.exists():
        return {}

    env_vars: dict[str, str] = {}
    for line in env_file.read_text().splitlines():
        line = line.strip()
        if not line or line.startswith("#"):
            continue
        if "=" in line:
            key, _, value = line.partition("=")
            key = key.strip()
            value = value.strip()
            # Remove inline comments
            if "#" in value and not value.startswith('"') and not value.startswith("'"):
                value = value.split("#")[0].strip()
            env_vars[key] = value
    return env_vars


def update_env_file(
    updates: dict[str, str],
    env_file_path: Path | None = None,
) -> Path:
    """Update existing .env file with new values.

    Args:
        updates: Dict of env var names to new values
        env_file_path: Optional custom path (defaults to ~/.ploston/.env)

    Returns:
        Path to the updated .env file
    """
    env_file = env_file_path or ENV_FILE

    # Load existing
    existing = load_env_file(env_file)

    # Merge updates
    existing.update(updates)

    # Get runner token (required)
    runner_token = existing.pop("PLOSTON_RUNNER_TOKEN", generate_runner_token())

    # Write back
    return write_env_file(runner_token, existing, env_file)


def merge_env_file(
    new_vars: dict[str, str],
    section: str = "General",
    env_file_path: Path | None = None,
) -> Path:
    """Merge new env vars into existing .env file.

    Section-aware merging that preserves existing values and structure.
    Only adds new keys or updates keys in the same section.

    Args:
        new_vars: Dict of env var names to values to merge
        section: Section name for new variables (e.g., "Bootstrap", "Runner")
        env_file_path: Optional custom path (defaults to ~/.ploston/.env)

    Returns:
        Path to the merged .env file
    """
    env_file = env_file_path or ENV_FILE

    # Load existing file with sections
    existing_entries = load_env_file_with_sections(env_file)

    # Merge new vars - only add if not already present
    for key, value in new_vars.items():
        if key not in existing_entries:
            existing_entries[key] = EnvEntry(value=value, section=section)

    # Write back with sections preserved
    return write_env_file_with_sections(existing_entries, env_file)


class EnvEntry:
    """Represents an environment variable entry with metadata."""

    def __init__(self, value: str, section: str = "General", comment: str | None = None):
        """Initialize entry.

        Args:
            value: The environment variable value
            section: Section this variable belongs to
            comment: Optional inline comment
        """
        self.value = value
        self.section = section
        self.comment = comment


def load_env_file_with_sections(env_file_path: Path | None = None) -> dict[str, EnvEntry]:
    """Load environment variables from .env file preserving section info.

    Args:
        env_file_path: Optional custom path (defaults to ~/.ploston/.env)

    Returns:
        Dict of env var names to EnvEntry objects
    """
    env_file = env_file_path or ENV_FILE
    if not env_file.exists():
        return {}

    entries: dict[str, EnvEntry] = {}
    current_section = "General"

    for line in env_file.read_text().splitlines():
        stripped = line.strip()

        # Track section headers (comments starting with #)
        if stripped.startswith("# ") and stripped.endswith(":"):
            # Section header like "# Bootstrap settings:"
            current_section = stripped[2:-1].strip()
            continue
        elif stripped.startswith("# ") and "settings" in stripped.lower():
            # Alternative section header like "# Runner authentication (auto-generated)"
            current_section = stripped[2:].split("(")[0].strip()
            continue

        # Skip empty lines and pure comments
        if not stripped or stripped.startswith("#"):
            continue

        # Parse key=value
        if "=" in stripped:
            key, _, rest = stripped.partition("=")
            key = key.strip()

            # Handle inline comments
            value = rest.strip()
            comment = None
            if "#" in value and not value.startswith('"') and not value.startswith("'"):
                value, _, comment = value.partition("#")
                value = value.strip()
                comment = comment.strip()

            entries[key] = EnvEntry(value=value, section=current_section, comment=comment)

    return entries


def write_env_file_with_sections(
    entries: dict[str, EnvEntry],
    env_file_path: Path | None = None,
) -> Path:
    """Write .env file preserving section structure.

    Args:
        entries: Dict of env var names to EnvEntry objects
        env_file_path: Optional custom path (defaults to ~/.ploston/.env)

    Returns:
        Path to the written .env file
    """
    env_file = env_file_path or ENV_FILE
    env_file.parent.mkdir(parents=True, exist_ok=True)

    # Group entries by section
    sections: dict[str, list[tuple[str, EnvEntry]]] = {}
    for key, entry in entries.items():
        if entry.section not in sections:
            sections[entry.section] = []
        sections[entry.section].append((key, entry))

    # Define section order (known sections first, then alphabetical)
    section_order = ["General", "Bootstrap", "Runner authentication", "Imported MCP server secrets"]
    ordered_sections = []
    for s in section_order:
        if s in sections:
            ordered_sections.append(s)
    for s in sorted(sections.keys()):
        if s not in ordered_sections:
            ordered_sections.append(s)

    # Build output
    lines = ["# Generated by: ploston", "# Environment configuration for Ploston", ""]

    for section in ordered_sections:
        if section not in sections:
            continue

        # Section header
        lines.append(f"# {section}:")

        # Sort entries within section
        for key, entry in sorted(sections[section], key=lambda x: x[0]):
            if entry.comment:
                lines.append(f"{key}={entry.value}  # {entry.comment}")
            else:
                lines.append(f"{key}={entry.value}")

        lines.append("")  # Blank line after section

    env_file.write_text("\n".join(lines))
    return env_file


class EnvFileManager:
    """Manager for .env file operations.

    Provides a class-based interface for env file management.
    """

    def __init__(self, env_file_path: Path | None = None):
        """Initialize manager.

        Args:
            env_file_path: Optional custom path (defaults to ~/.ploston/.env)
        """
        self.env_file = env_file_path or ENV_FILE

    def generate_token(self) -> str:
        """Generate a new runner token."""
        return generate_runner_token()

    def write(
        self,
        runner_token: str,
        env_vars: dict[str, str | None] | None = None,
    ) -> Path:
        """Write .env file."""
        return write_env_file(runner_token, env_vars, self.env_file)

    def load(self) -> dict[str, str]:
        """Load .env file."""
        return load_env_file(self.env_file)

    def update(self, updates: dict[str, str]) -> Path:
        """Update .env file."""
        return update_env_file(updates, self.env_file)

    def merge(self, new_vars: dict[str, str], section: str = "General") -> Path:
        """Merge new vars into .env file with section awareness."""
        return merge_env_file(new_vars, section, self.env_file)

    def load_with_sections(self) -> dict[str, EnvEntry]:
        """Load .env file with section information."""
        return load_env_file_with_sections(self.env_file)

    @property
    def exists(self) -> bool:
        """Check if .env file exists."""
        return self.env_file.exists()
